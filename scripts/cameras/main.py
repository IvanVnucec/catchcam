
def load_cameras_from_csvs():
    import os
    import csv
    import re
    def extract_speed_limit(filename):
        match = re.search(r'Speed_(\d+)', filename)
        if match:
            return int(match.group(1))
        raise ValueError(f"Unable to extract speed limit from filename: {filename}")

    def read_file_with_fallback_encoding(filename):
        encodings = ['utf-8', 'iso-8859-1', 'windows-1252']
        for encoding in encodings:
            try:
                with open(filename, 'r', encoding=encoding) as file:
                    return file.read()
            except UnicodeDecodeError:
                continue
        raise ValueError(f"Unable to read {filename} with any of the attempted encodings")
    cameras = []
    SCDB_DIR = './scdb'
    for filename in os.listdir(SCDB_DIR):
        if filename.endswith('.csv'):
            try:
                file = os.path.join(SCDB_DIR, filename)
                speed_limit = extract_speed_limit(file)
                content = read_file_with_fallback_encoding(file)
                reader = csv.reader(content.splitlines())
                for row in reader:
                    if len(row) >= 2:  # Ensure the row has at least 2 columns
                        cameras.append({
                            'lat': float(row[1]),
                            'lon': float(row[0]),
                            'limit': int(speed_limit)
                        })
            except ValueError as e:
                print(f"Error processing {file}: {str(e)}")
    return cameras

def generate_c_file(data_list):
    from datetime import datetime
    with open('cameras.c', 'w') as c_file:
        # Add generation comment
        current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        c_file.write(f'// This file was generated by a script on {current_date}\n\n')

        c_file.write('#include <stdint.h>\n\n')
        c_file.write('struct camera {\n')
        c_file.write('  float lat;\n')
        c_file.write('  float lon;\n')
        c_file.write('  uint8_t limit;\n')
        c_file.write('};\n\n')

        c_file.write(f'#define NUM_CAMERAS {len(data_list)}\n\n')

        c_file.write('static const struct camera cameras[NUM_CAMERAS] = {\n')
        for camera in data_list:
            c_file.write(f'    {{ {camera["lat"]:.6f}f, {camera["lon"]:.6f}f, {camera["limit"]} }},\n')
        c_file.write('};\n')

def get_cameras_from_overpass():
    import urllib.request
    import urllib.parse
    import json
    def get_speed_cameras_croatia():
        overpass_url = "http://overpass-api.de/api/interpreter"
        overpass_query = """
        [out:json][timeout:25];
        area["ISO3166-1"="HR"]->.croatia;
        nwr["highway"="speed_camera"](area.croatia);
        out geom;
        """

        data = urllib.parse.urlencode({'data': overpass_query}).encode()
        req = urllib.request.Request(overpass_url, data=data, method='GET')

        with urllib.request.urlopen(req) as response:
            if response.getcode() != 200:
                raise Exception(f"HTTP request failed with status code {response.getcode()}")
            return json.loads(response.read())['elements']
    try:
        overpass = get_speed_cameras_croatia()
        cameras = []
        for cam in overpass:
            lat, lon = cam['lat'], cam['lon']
            maxspeed = cam['tags'].get('maxspeed')
            limit = int(maxspeed) if maxspeed else None
            cameras.append({'lat': lat, 'lon': lon, 'limit': limit})
        return cameras
    except Exception as e:
        print(f"An error occurred: {str(e)}")

def distance(cam1, cam2):
    import math

    lat1, lon1 = cam1['lat'], cam1['lon']
    lat2, lon2 = cam2['lat'], cam2['lon']

    # Convert decimal degrees to radians
    lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])

    # Haversine formula
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
    c = 2 * math.asin(math.sqrt(a))

    # Radius of earth in meters
    r = 6376100.0
    return c * r

def get_cameras_close_to_each_other(cams1, cams2, dist=100.0):
    close = []
    for cam1 in cams1:
        for cam2 in cams2:
            if distance(cam1, cam2) < 100.0:
                close.append((cam1, cam2))
    return close

def main():
    csv_cams = load_cameras_from_csvs()
    print(f"{len(csv_cams)=}")
    overpass_cams = get_cameras_from_overpass()
    print(f"{len(overpass_cams)=}")

    import folium
    from folium.plugins import MeasureControl
    m = folium.Map(location=(45.80924524276232, 15.97520722705126), zoom_start=12)

    def custom_marker(cam, radius, color, tooltip=""):
        lat, lon = cam['lat'], cam['lon']
        gmaps = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
        return folium.CircleMarker([lat, lon],
            tooltip=tooltip,
            popup=f"""
<p>Speed limit: {cam['limit']}</p>
<p>Coordinates: {lat}, {lon}</p>
<p><a href="{gmaps}" target="_blank" rel="noopener noreferrer">{lat}, {lon}</a></p>""",
            radius=radius,
            color=color,
            fill=False)

    for cam in csv_cams:
        custom_marker(cam, tooltip="CSV", radius=5, color='red').add_to(m)

    for cam in overpass_cams:
        custom_marker(cam, tooltip="Overpass", radius=5, color='blue').add_to(m)

    ovp_cams_not_in_csv = []
    for ovp_cam in overpass_cams:
        in_csv = False
        for csv_cam in csv_cams:
            if distance(ovp_cam, csv_cam) <= 100.0:
                in_csv = True
                break
        if not in_csv:
            ovp_cams_not_in_csv.append(ovp_cam)
    print(f"{len(ovp_cams_not_in_csv)=}")

    for cam in ovp_cams_not_in_csv:
        custom_marker(cam, tooltip="/CSV", radius=8, color='green').add_to(m)

    m.add_child(MeasureControl())
    m.save("index.html")
    exit()

    close_cams = get_cameras_close_to_each_other(csv_cams, overpass_cams)
    for cam1, cam2 in close_cams:
        if cam1['limit'] != cam2['limit']:
            print(f"csv {cam1}, ovp {cam2}")
    print(f"{len(close_cams)=}")
if __name__ == "__main__":
    main()
